* Unity 용량 줄이기

 

'Library\metadata' 폴더 삭제

'Library\ScriptAssemblies' 폴더 삭제

 

 

 

* Unity 최적화

 

1. 프로파일러를 이용해서 병목현상 체크하기.
 - Window > Profiler 메뉴를 이용한다.

2. 컬링 기법 이용하기.
 - 프러스텀 컬링 (Frustum Culling) : 레이어별로 컬링 거리를 따로 지정 가능하다.
 - 오클루전 컬링 (Occlusion Culling) : Window > Occlusion Culling 메뉴를 이용한다.

3. 드로우콜 체크하기.
 - 드로우콜은 게임 오브젝트에 설정된 재질의 셰이더 패스당 하나씩 일어난다.
 - 렌더러에 사용한 재질의 수만큼 드로우콜이 발생한다.
 - 드로우콜의 발생을 최소화하기 위해서는 성질이 동일한 물체들은 하나의 메쉬와 재질을 사용하도록 통합하는 것이다.
   (이를 위해 최상위 오브젝트에 사용할 수 있는 CombineChildren 컴포넌트가 Scripts 패키지에서 제공된다.)
 - CombineChildren 컴포넌트를 사용할 경우, 하위 오브젝트가 모두 하나가 되어서 빛의 계산을 모두 수행하는 등 불필요한 계산이 발생하는 단점도 있다.
 - 같은 셰이더를 사용하더라도 다른 텍스처를 사용하면 드로우콜이 증가한다.
 - 위와 같은 경우, 텍스처를 모두 합친 큰 텍스처(텍스처 아틀라스)를 만들어 서로 공유하면 드로우콜을 줄일 수 있다.

4. 배칭기능 사용하기.
 - Edit > Project Settings > Player 에서 설정.
 - 정적 배칭을 사용할 경우, static으로 설정된 게임 오브젝트에서 동일한 재질을 사용하는 물체가 있는 경우 자동으로 통합한다.
 - 정적 배칭을 사용할 경우, CombineChildren처럼 통합되는 오브젝트를 모두 하나의 커다란 메쉬로 만들어서 따로 저장하게 된다. (메모리 사용 증가)
 - 동적 배칭은 움직이는 물체를 대상으로 동일한 재질을 사용하는 경우, 자동으로 메쉬를 통합하여 드로우콜을 줄여주는 기능이다.
 - 동적 배칭은 계산양이 많으므로, 정점이 900개 미만인 오브젝트만을 대상으로 수행된다.

5. 권장 텍스처 사용하기.
 - 아이폰 (PowerVR) : PVRTC
 - 안드로이드 (Tegra) : DXT
 - 안드로이드 (Adreno) : ATC
 - 안드로이드 (공통) : ETC1

6. 오버드로우
 - 겹치는 부분의 픽셀을 다시 그리는 것을 오버드로우라고 한다.
 - 오버드로우를 줄이는 가장 좋은 방법은 큰 영역을 차지하는 물체를 먼저 그리도록 하는 것이다.

7. 물리엔진
 - 유니티에서는 물리 엔진 작업을 렌더링 작업과 별개로 수행한다.
 - 물리 엔진 작업은 FixedUpdate() 함수에서 수행되며, 0.02초로 매우 짧아서 FixedUpdate() 함수가 여러 번 수행된 후 Update() 함수가 호출된다.
 - 따라서 FixedUpdate() 함수의 코드에는 필요한 기능만 넣도록 한다.
 - 게임 진행에 문제가 없다면 Edit > Project Settings > Time 메뉴에서 FixedUpdate() 함수의 실행 주기를 늘리는 것도 좋다.

8. 충돌체의 이동
 - 리지드 바디가 없는 고정 충돌체를 움직이면 CPU에 부하가 발생된다.
 - 이 경우, 리지드 바디를 추가하고 IsKinematics 옵션을 준 후 움직이는 것이 좋다.

9. Maximum Allowed timestep 조절
 - 여타 요인으로 시스템에 부하가 걸려 지정된 시간보다 오래 멈출 경우, 물리 계산을 건너뛰도록 설정하는 기능.
 - Edit > Project Settings > Time 메뉴에서 설정.

10. Solver Iteration Count 조절
 - 물리 관련 계산을 얼마나 정교하게 할 것인지 지정. ( 높을수록 정교해진다. )
 - Edit > Project Settings > Physics 메뉴에서 설정.

11. Sleep 조절
 - 리지드 바디의 속력이 지정된 수치보다 작을 경우, 자동으로 휴면 상태에 들어간다.
 - Edit > Project Settings > Physics 메뉴에서 설정.
 - Physics.Sleep() 함수를 이용해서 강제 휴면 상태를 만들 수도 있다. 
   (Awake()함수에서 사용하면 레벨이 로딩되기 전까지 물리 엔진 사용을 자제시킬 수 있다.)

12. 유니티 라이브러리 사용 시 주의사항
 - 유니티의 핵심기능은 모두 c++로 작성되어 있다.
 - 예를 들어 transform.position 에서 transform은 c#의 속성으로 정의되어 있고 position은 c++영역에 작성되어 있다.
 - 때문에 transform.position 구문을 자주 사용하는 것보다 미리 변수에 저장해두고 사용하는 방식이 좋다.
 - FindObject 계열 함수들은 매우 느리다. ( 미리 찾아서 저장해두는게 좋다. )
 - Instantiate 와 Destroy 함수를 이용한 프리팹의 생성과 소멸은 비용이 크다. ( 활성화와 비활성화를 이용하는 것이 좋다. )
 - 가급적이면 Update 함수보다 CoRoutine 함수를 사용하도록 한다.
 - 박싱과 언박싱은 부하가 큰 작업이다.
 - 나눗셈보다는 곱셈이 몇십배 빠르다.
 - magnitude 보다 sqrMagnitude를 사용해서 제곱근 계산을 줄이도록 한다.
 - 삼각함수의 값은 상수로 저장해두고 사용하는 게 좋다.
 - 고정 문자열은 readonly 혹은 const 키워드를 사용하여 가비지 컬렉션으로 부터 벗어나도록 한다.

13. 배열 관리
 - Array : 아이템들의 크기가 일정하고, 순서가 변할 일이 없다면 일반 배열을 사용하는 것이 가장 빠르게 동작한다.
 - ArrayList : 아이템들의 크기가 자주 변하고 순서도 자주 바뀌는데다, 모든 아이템이 레퍼런스형일 경우 사용한다.
 - List<T> : ArrayList인데 저장하는 데이터가 밸류 타입이면 제네릭 List를 사용해야 박싱이 일어나지 않는다.
 - Hashtable : 키와 값으로 구성된 사전류의 데이터를 관리할 때 해시 테이블을 사용하면 편리하다.
 - Dictionary<K, V> : 해시 테이블과 동일한 기능을 수행하나, 데이터의 형식이 밸류 타입이면 제네릭 Dictionary를 사용해야 박싱이 일어나지 않는다.